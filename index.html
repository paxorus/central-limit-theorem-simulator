<html>
<head>
	<!-- jQuery -->
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
	<!-- Vega-Lite -->
    <script src="https://cdn.jsdelivr.net/npm/vega@5.10.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-lite@4.10.4"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-embed@6.5.2"></script>

	<style>
		body {font-family: sans-serif;}
	</style>
</head>
<body>

<center>
	<div id="population-distribution"></div>
	<div id="sampling-distribution" style="margin-top: 20px"></div>
</center>


<script>

const ORIGINAL_DISTRIBUTION_POPULATION_SIZE = 100;// Size of original distribution; any number works
const ORIGINAL_DISTRIBUTION_SAMPLE_SIZE = 100;// Size of sample from original distribution to mean; minimal impact to sampling distribution after 10
const SAMPLING_DISTRIBUTION_SAMPLE_SIZE = 1e5;// Size of sample from means to sampling distribution; approaches Infinity, ideal resolution after 100,000

function sample(distribution) {
	const sample = [];
	for (let i = 0; i < ORIGINAL_DISTRIBUTION_SAMPLE_SIZE; i ++) {
		sample.push(distribution[Math.floor(Math.random() * distribution.length)]);
	}
	return sample;
}

/**
 * Mean. Valid for population or sample.
 * μ(X) = Σx / n 
 */
function mean(distribution) {
	const total = distribution.reduce((acc, x) => acc + x);

	return total / distribution.length;
}

/**
 * Population standard deviation.
 * σ(X) = sqrt(Σ(x - μ)^2 / n)
 */
function standardDeviation(distribution, mean) {
	const numerator = distribution.reduce((acc, x) => acc + Math.pow(x - mean, 2), 0);

	return Math.sqrt(numerator / distribution.length);
}

/**
 * Probability density function for Normal distribution.
 * Normal(x) = e^(-(x - μ)^2/2σ^2) / (σ * sqrt(2π))
 */
function normalPdf(x, mu, sigma) {
	const exponent = - Math.pow((x - mu) / sigma, 2) / 2;

	return Math.pow(Math.E, exponent) / (sigma * Math.sqrt(2 * Math.PI));
}

function computeAlignment(sampling, theoreticalMean, theoreticalStdDev) {
	// Bin the sampling distribution, as Plotly has done for the visualization.
	const NUMBER_OF_BINS = 100;
	const min = sampling.reduce((acc, x) => Math.min(acc, x));
	const max = sampling.reduce((acc, x) => Math.max(acc, x));
	const bins = new Array(NUMBER_OF_BINS).fill(0);
	const binWidth = (max - min + 1) / NUMBER_OF_BINS;
	sampling.forEach(x => {
		const binIndex = Math.floor((x - min) / binWidth);
		bins[binIndex] ++;
	});

	const mu = theoreticalMean;
	const sigma = theoreticalStdDev;

	const [intersection, union] = bins.map((x, i) => {

		const idealFrequency = normalPdf((i + 0.5) * binWidth + min, mu, sigma) * binWidth;
		
		const actualFrequency = x / sampling.length;
		
		return [
			Math.min(actualFrequency, idealFrequency),
			Math.max(actualFrequency, idealFrequency)
		];
	}).reduce((acc, ratio) => {
		return [acc[0] + ratio[0], acc[1] + ratio[1]];
	}, [0, 0]);

	return intersection / union;
}

function binData(dataArray) {
	const NUMBER_OF_BINS = 25;
	const min = dataArray.reduce((acc, x) => Math.min(acc, x));
	const max = dataArray.reduce((acc, x) => Math.max(acc, x));
	const bins = new Array(NUMBER_OF_BINS).fill(0);
	const binWidth = Math.ceil((max - min + 1) / NUMBER_OF_BINS);

	dataArray.forEach(x => {
		const binIndex = Math.floor((x - min) / binWidth);
		bins[binIndex] ++;
	});

	return bins.map((x, i) => ({
		start: i * binWidth + min,
		center: (i + 0.5) * binWidth + min,
		end: (i + 1) * binWidth + min,
		count: x
	}));
}

function getHistogramPlotSpec(histogramData) {
	return {
		"data": {
			"values": histogramData
		},
		"mark": "bar",
		"encoding": {
			"x": {
				"field": "start",
				"bin": {"binned": true, "step": 2},
				"type": "quantitative",
				"axis": {"title": null}
			},
			"x2": {"field": "end"},
			"y": {"field": "count", "type": "quantitative"}
		}
	};
}

function getLinePlotSpec(lineData) {
	return {
		"data": {
			"values": lineData
		},
		"mark": {"type": "line", "stroke": "#85A9C5"},
		"encoding": {
			"x": {"field": "center", "type": "quantitative"},
			"y": {"field": "count", "type": "quantitative"}
		}
	};
}

function main() {
	// Skewed-right distribution
	const originalDistribution = [];
	for (let i = 0; i < ORIGINAL_DISTRIBUTION_POPULATION_SIZE; i ++) {
		originalDistribution.push(i * i);
	}

	// Generate sampling distribution.
	const samplingDistribution = [];
	for (let i = 0; i < SAMPLING_DISTRIBUTION_SAMPLE_SIZE; i ++) {
		const sampleMean = mean(sample(originalDistribution));
		samplingDistribution.push(sampleMean);
	}

	const theoreticalMean = mean(originalDistribution);
	const originalStdDev = standardDeviation(originalDistribution, theoreticalMean);
	const theoreticalStdDev = originalStdDev / Math.sqrt(ORIGINAL_DISTRIBUTION_SAMPLE_SIZE);
	const samplingMean = mean(samplingDistribution);
	const samplingStdDev = standardDeviation(samplingDistribution, samplingMean);

	// Plot population distribution.
	const subtitle = [
		`μ = ${theoreticalMean.toFixed(2)}, σ = ${originalStdDev.toFixed(2)}, n = ${originalDistribution.length}`,
		`σ / √(nMeans) = ${theoreticalStdDev.toFixed(2)}`
	];

	vegaEmbed("#population-distribution", {
		"title": {
			"text": "Population Distribution",
			"fontSize": 24,
			"subtitle": subtitle,
			"subtitleColor": "#555",
			"subtitleFontSize": 14
		},
		"$schema": "https://vega.github.io/schema/vega-lite/v4.json",
		"layer": [getHistogramPlotSpec(binData(originalDistribution))],
		"width": 700
	});

	// Compute alignment with ideal Normal curve.
	const alignment = computeAlignment(samplingDistribution, theoreticalMean, theoreticalStdDev);
	const alignmentPercentage = (alignment * 100).toFixed(2);

	// Plot sampling distribution.
	const subtitle2 = [
		`μ = ${samplingMean.toFixed(2)}, σ = ${samplingStdDev.toFixed(2)}, n = ${samplingDistribution.length}`,
		`normalcy = ${alignmentPercentage}%`
	];

	const samplingFrequencies = binData(samplingDistribution);
	vegaEmbed("#sampling-distribution", {
		"title": {
			"text": "Sampling Distribution",
			"fontSize": 24,
			"subtitle": subtitle2,
			"subtitleColor": "#555",
			"subtitleFontSize": 14
		},
		"$schema": "https://vega.github.io/schema/vega-lite/v4.json",
		"layer": [
			getHistogramPlotSpec(samplingFrequencies),
			getLinePlotSpec(samplingFrequencies)
		],
		"width": 700
	});
}

main();
</script>
</body>
</html>