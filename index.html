<html>
<head>
	<!-- jQuery -->
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
	<!-- Plotly -->
	<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
	<style>
		body {font-family: sans-serif;}
	</style>
</head>
<body>

<center>
	<div id="population-distribution" style="width:800px;height:300px;"></div>
	<div id="sampling-distribution" style="width:800px;height:300px;"></div>

	<div id="alignment"></div>
</center>


<script>

const ORIGINAL_DISTRIBUTION_POPULATION_SIZE = 100;// Size of original distribution; any number works
const ORIGINAL_DISTRIBUTION_SAMPLE_SIZE = 100;// Size of sample from original distribution to mean; minimal impact to sampling distribution after 10
const SAMPLING_DISTRIBUTION_SAMPLE_SIZE = 1e5;// Size of sample from means to sampling distribution; approaches Infinity, ideal resolution after 100,000

function sample(distribution) {
	const sample = [];
	for (let i = 0; i < ORIGINAL_DISTRIBUTION_SAMPLE_SIZE; i ++) {
		sample.push(distribution[Math.floor(Math.random() * distribution.length)]);
	}
	return sample;
}


/**
 * Mean. Valid for population or sample.
 * μ(X) = Σx / n 
 */
function mean(distribution) {
	const total = distribution.reduce((acc, x) => acc + x);

	return total / distribution.length;
}

/**
 * Population standard deviation.
 * σ(X) = sqrt(Σ(x - μ)^2 / n)
 */
function standardDeviation(distribution, mean) {
	const numerator = distribution.reduce((acc, x) => acc + Math.pow(x - mean, 2), 0);

	return Math.sqrt(numerator / distribution.length);
}

/**
 * Probability density function for Normal distribution.
 * Normal(x) = e^(-(x - μ)^2/2σ^2) / (σ * sqrt(2π))
 */
function normalPdf(x, mu, sigma) {
	const exponent = - Math.pow((x - mu) / sigma, 2) / 2;

	return Math.pow(Math.E, exponent) / (sigma * Math.sqrt(2 * Math.PI));
}

function computeAlignment(sampling, theoreticalMean, theoreticalStdDev) {
	// Bin the sampling distribution, as Plotly has done for the visualization.
	const NUMBER_OF_BINS = 100;
	const min = sampling.reduce((acc, x) => Math.min(acc, x));
	const max = sampling.reduce((acc, x) => Math.max(acc, x));
	const bins = new Array(NUMBER_OF_BINS).fill(0);
	const binWidth = (max - min + 1) / NUMBER_OF_BINS;
	sampling.forEach(x => {
		const binIndex = Math.floor((x - min) / binWidth);
		bins[binIndex] ++;
	});

	const mu = theoreticalMean;
	const sigma = theoreticalStdDev;

	const [intersection, union] = bins.map((x, i) => {

		const idealFrequency = normalPdf((i + 0.5) * binWidth + min, mu, sigma) * binWidth;
		
		const actualFrequency = x / sampling.length;
		
		return [
			Math.min(actualFrequency, idealFrequency),
			Math.max(actualFrequency, idealFrequency)
		];
	}).reduce((acc, ratio) => {
		return [acc[0] + ratio[0], acc[1] + ratio[1]];
	}, [0, 0]);

	return intersection / union;
}

function main() {
	// Skewed-right distribution
	const originalDistribution = [];
	for (let i = 0; i < ORIGINAL_DISTRIBUTION_POPULATION_SIZE; i ++) {
		originalDistribution.push(i * i);
	}

	// Generate sampling distribution.
	const samplingDistribution = [];
	for (let i = 0; i < SAMPLING_DISTRIBUTION_SAMPLE_SIZE; i ++) {
		const sampleMean = mean(sample(originalDistribution));
		samplingDistribution.push(sampleMean);
	}

	const theoreticalMean = mean(originalDistribution);
	const originalStdDev = standardDeviation(originalDistribution, theoreticalMean);
	const theoreticalStdDev = originalStdDev / Math.sqrt(ORIGINAL_DISTRIBUTION_SAMPLE_SIZE);
	const samplingMean = mean(samplingDistribution);
	const samplingStdDev = standardDeviation(samplingDistribution, samplingMean);

	// Plot
	const subtitle = `μ = ${theoreticalMean.toFixed(2)}, σ = ${originalStdDev.toFixed(2)}, n = ${originalDistribution.length}`
		+ `<br>σ / √(nMeans) = ${theoreticalStdDev.toFixed(2)}`;
	Plotly.newPlot('population-distribution', [{
		x: originalDistribution,
		type: "histogram"
	}], {
		title: "Population Distribution<br><span style='font-size: 14px; color: #777'>" + subtitle + "</span>"
	});

	const subtitle2 = `μ = ${samplingMean.toFixed(2)}, σ = ${samplingStdDev.toFixed(2)}, n = ${samplingDistribution.length}`;
	const x = Plotly.newPlot('sampling-distribution', [{
		x: samplingDistribution,
		type: "histogram"
	}], {
		title: "Sampling Distribution<br><span style='font-size: 14px; color: #777'>" + subtitle2 + "</span>",
	});

	// Compute alignment with ideal Normal curve.
	const alignment = computeAlignment(samplingDistribution, theoreticalMean, theoreticalStdDev);
	const alignmentPercentage = (alignment * 100).toFixed(2);
	$("#alignment").text(`Alignment: ${alignmentPercentage} %`);
}

main();
</script>
</body>
</html>